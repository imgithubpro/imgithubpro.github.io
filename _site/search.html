<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | imgithubpro</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="imgithubpro" href="/feed.xml" />

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
	

	<!-- KaTeX -->
	

	<!-- Google Analytics -->
	
</head>

  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/avatar.png" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">imgithubpro</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			<li>
				<a class="page-link" href="/categories/">
					Categories
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			<li>
				<a class="page-link" href="/tags.html">
					tags
				</a>
			</li>
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			


<li>
	<a href="mailto:imgoooglepro@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/imgithubpro" title="Follow on GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>




























            
            <!-- Search bar -->
            
            <li>
            <form action="/search.html" method="get">
                <input type="text" id="search-box" name="query" placeholder="Search" class="">
                <button type="submit" class="">
                    <i class="fa fa-fw fa-search"></i>
                </button>
            </form>
            </li>
            
		</ul>
	</nav>
    
</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
    
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "docker-2018-04-29-001-html": {
        "title": "도커 서비스 구성하기",
        "tags": "docker, devops, service, compose",
        "date": "April 29, 2018",
        "author": "",
        "category": "",
        "content": "  docker-compose.yml 을 사용하여 도커 서비스를 구성하고 실행해보자.도커의 서비스란?  “프로덕션 컨테이너”로 실제 서비스의 기능 블럭  어떤 포트들을 사용해야 하는지 얼마나 많은 컨테이 복제본들을 실행해야 하는지 정의  서비스 확장 시, 프로세스의 서비스는 해당 소프트웨어를 실행하는 컨테이너 인스턴스의 수 증가  도커는 서비스 확장과 실행을 위해 docker-compose.yml 사용docker-compose.yml 파일 작성하기docker-compose 설치Linux 기준 Compose 설치  proxy를 사용하는 경우: -x http://proxy.yourhost:port 를 추가$ sudo curl -L https://github.com/docker/compose/releases/download/1.21.0/docker-compose-$(uname -s)-$(uname -m) -o /usr/local/bin/docker-compose$ sudo chmod +x /usr/local/bin/docker-compose$ docker-compose --version # testdocker-compose.yml  docker-compose.yml파일은 도커 컨테이너들이 서비스에서 어떻게 작동하는지 정의하는 YAML 파일  앞에서 만들었던 username/repo:tag 이미지를 사용해서 실습    version: \"3\"services:web:  # replace username/repo:tag with your name and image details  image: username/repo:tag  deploy:    replicas: 5    resources:      limits:        cpus: \"0.1\" # 10% of the CPU        memory: 50M    restart_policy:      condition: on-failure  ports:    - \"80:80\"  networks:    - webnetnetworks:webnet:          새로운 로드밸런스된 앱을 실행하기docker stack deploy 명령얼 사용하기 전에 아래 명령 수행$ docker swarm initgetstartedlab 이라는 이름으로 앱을 실행$ docker statck deploy -c docker-compose.yml getstartedlab  우리가 설정가 앱은 각 호스트당 배포된 이미지가 5개의 컨테이너 인스턴스로 실행되는 싱글 서비스 스택으로 구성서비스 아이디 확인$ docker service ls  web 서비스의 결과를 확인해보면 서비스의 이름은 getstartedlab_web으로 출력  서비스에서 실행되는 각 단일 컨테이너가 테스크  테스크는 docker-compose.yml파일에 정의한 replicas 갯수만큼 순차적으로 증가하는 유니크한 아이디를 가짐해당 서비스의 테스크 아이디 확인$ docker service ps getstartedlab_web필터 없이 모든 서비스 확인$ docker container ls -q인스턴스 결과 확인$ curl -4 http://localhost  컨테이너는 각 요청마다 라운드로빈 방식으로 선택앱 스케일 수정docker-compose.yml 파일의 replicas를 수정 후에 docker statck deploy 명령으로 다시 실행$ docker stack deploy -c docker-compose.yml getstartedlab  도커는 해당 스택을 다운시키거나 킬 시킬필요 없이 업데이트앱 종료docker stack rm명령으로 앱 다운$ docker stack rm getstartedlabswarm 다운$ docker swarm leave --force사용한 명령어 정리docker stack ls                                            # List stacks or appsdocker stack deploy -c &lt;composefile&gt; &lt;appname&gt;  # Run the specified Compose filedocker service ls                 # List running services associated with an appdocker service ps &lt;service&gt;                  # List tasks associated with an appdocker inspect &lt;task or container&gt;                   # Inspect task or containerdocker container ls -q                                      # List container IDsdocker stack rm &lt;appname&gt;                             # Tear down an applicationdocker swarm leave --force      # Take down a single node swarm from the manager",
        "url": "//docker/2018/04/29/001.html"
      }
      ,
    
      "docker-2018-04-28-001-html": {
        "title": "도커를 이용한 간단한 앱 만들기",
        "tags": "docker, devops",
        "date": "April 28, 2018",
        "author": "",
        "category": "",
        "content": "  Dockerfile을 사용하여 컨테이너를 정의하여 실행해보자.생성한 이미지들을 리모트 저장소에 저장하고, 해당 이미지를 사용한다.도커 파일을 이용한 컨테이너 정의  Dockerfile은 컨테이너의 환경 설정을 정의  디스크나 네트워크 인터페이스에 대한 접근을 가상화하여 환경 설정에 정의하여 시스템으로부터 분리  Dockerfile을 통해서 정의한 app은 어디서나 동일하게 실행 가능도커파일 정의하기  빈 디렉토리를 생성하여 그 안에 아래 3개의 파일들을 입력Dockerfile# Use an official Python runtime as a parent imageFROM python:2.7-slim# Set the working directory to /appWORKDIR /app# Copy the current directory contents into the container at /appADD . /app# Install any needed packages specified in requirements.txtRUN pip install --trusted-host pypi.python.org -r requirements.txt# Make port 80 available to the world outside this containerEXPOSE 80# Define environment variableENV NAME World# Run app.py when the container launchesCMD [\"python\", \"app.py\"]requirements.txtFlaskRedisapp.pyfrom flask import Flaskfrom redis import Redis, RedisErrorimport osimport socket# Connect to Redisredis = Redis(host=\"redis\", db=0, socket_connect_timeout=2, socket_timeout=2)app = Flask(__name__)@app.route(\"/\")def hello():    try:        visits = redis.incr(\"counter\")    except RedisError:        visits = \"&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;\"    html = \"&lt;h3&gt;Hello {name}!&lt;/h3&gt;\" \\           \"&lt;b&gt;Hostname:&lt;/b&gt; {hostname}&lt;br/&gt;\" \\           \"&lt;b&gt;Visits:&lt;/b&gt; {visits}\"    return html.format(name=os.getenv(\"NAME\", \"world\"), hostname=socket.gethostname(), visits=visits)if __name__ == \"__main__\":    app.run(host='0.0.0.0', port=80)앱 빌드하기빌드를 위한 디렉토리 구조$ lsDockerfile\t\tapp.py\t\t\trequirements.txtdocker build 명령을 통해  Dockerfile로부터 이미지를 빌드  -t옵션을 사용해서 tag로 사용할 이름을 설정docker build -t friendlyhello .생성된 이미지 확인$ docker image lsREPOSITORY                TAG                 IMAGE ID            friendlyhello             latest              c2e684e3c029    [참고] 프록시 서버 설정  해당 서버 앞에 프록시 서버가 설정된 경우 ENV 명령을 통해서 Dockerfile에 해당 프록시 설정 추가  위에 Dockerfile에 EVN 설정 부분에 이어서 추가    # Set proxy server, replace host:port with values for your serversENV http_proxy host:portENV https_proxy host:port          앱 실행하기docker run 명령을 통해 앱을 실행  -p옵션을 통해 머신의 4000 포트와 컨테이너의 80 포트를 매핑docker run -p 4000:80 friendlyhello # &lt;host port&gt;:&lt;container port&gt;  파이썬의 해당 앱은 컨테이너 안에서 http://0.0.0.0:80에서 서비스  http://localhost:4000 URL로 컨테이너는 서비스하며 실제 80포트와의 매핑은 숨겨짐  CTRL+C로 종료해당 페이지 확인$ curl http://localhost:4000&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 07e1a6d098ac&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;앱을 백그라운드로 실행  -d옵션을 사용하면 detached mode로 데몬 상태로 실행docker run -d -p 4000:80 friendlyhello실행중인 컨테이너 확인$ docker container lsCONTAINER ID        IMAGE               COMMAND             CREATED07e1a6d098ac        friendlyhello       \"python app.py\"     About an hour ago해당 컨테이너 정지  CONTAINER ID를 사용해서 docker container stop 으로 해당 프로세스를 정지$ docker container stop 07e1a6d098ac07e1a6d098ac이미지 공유하기  생성한 이미지를 다른 곳에서 실행하기 위해 도커 레지스트리 사용  도커 레지스트리는 리포지토리들의 집합  리포지토리는 이미지들의 집합  도커 레지스트리 이외에도 도커는 도커 허브를 제공  도커 허브는 도커가 제공하는 공개된 이미지 저장소로 회원 가입으로 사용 가능도커 아이디로 로그인하기https://cloud.docker.com 을 통해서 회원 가입 후에 해당 아이디를 통해 로컬 머신에서 공개된 레지스트리로 로그인$ docker login이미지 태그하기레지스트리에 리포지토리 형식 : username/repository:tagdocker tag image username/repository:tag사용 예시docker tag friendlyhello john/get-started:part2docker image ls 로 새롭게 태그된 이미지 확인$ docker image lsREPOSITORY                TAG                 IMAGE ID            CREATED             SIZEfriendlyhello             latest              c2e684e3c029        29 hours ago        151 MBjohn/get-started          part2               c2e684e3c029        29 hours ago        151 MB이미지 업로드하기리포지토리에 태그된 이미지를 업로드 : Docker Hub 에서 확인 가능docker push username/repository:tag리모트 리포지토리 이미지로 실행하기docker run 으로 앱 실행 시  로컬 머신에 해당 이미지가 없는 경우 도커는 리포지토리에서 pull &amp; rundocker run -p 4000:80 username/repository:tag사용한 명령어 정리docker build -t friendlyhello .  # Create image using this directory's Dockerfiledocker run -p 4000:80 friendlyhello  # Run \"friendlyname\" mapping port 4000 to 80docker run -d -p 4000:80 friendlyhello         # Same thing, but in detached modedocker container ls                                # List all running containersdocker container ls -a             # List all containers, even those not runningdocker container stop &lt;hash&gt;           # Gracefully stop the specified containerdocker container kill &lt;hash&gt;         # Force shutdown of the specified containerdocker container rm &lt;hash&gt;        # Remove specified container from this machinedocker container rm $(docker container ls -a -q)         # Remove all containersdocker image ls -a                             # List all images on this machinedocker image rm &lt;image id&gt;            # Remove specified image from this machinedocker image rm $(docker image ls -a -q)   # Remove all images from this machinedocker login             # Log in this CLI session using your Docker credentialsdocker tag &lt;image&gt; username/repository:tag  # Tag &lt;image&gt; for upload to registrydocker push username/repository:tag            # Upload tagged image to registrydocker run username/repository:tag                   # Run image from a registry",
        "url": "//docker/2018/04/28/001.html"
      }
      ,
    
      "docker-2018-04-27-001-html": {
        "title": "도커 설치 &amp; hello world",
        "tags": "docker, devops",
        "date": "April 27, 2018",
        "author": "",
        "category": "",
        "content": "  CentOS 7 기준으로 도커를 설치하고, 간단한 hello-world 예제 실행해보자.도커란 무엇인가컨테이너 기반으로 애플리케이션을 개발, 배포, 실행할 수 있게 해주는 플랫폼이미지와 컨테이너이미지  애플리케이션이 실행되는데 필요한 모든 것이 포함된 실행가능한 패키지  코드, 런타임 라이브러리, 환경 변수, 설정 파일 등을 포함컨테이너  컨테이너는 이미지를 실행한 상태  이미지의 런타임 인스턴스  docker ps 명령을 통해서 실행중인 컨테이너 리스트 확인컨테이너와 가상머신컨테이너  리눅스에서 호스트 머신의 커널을 다른 컨테이너들과 공유하며 네이티브로 실행  개별 프로세스로 실행  애플리케이션에 필요한 메모리만을 사용하여 가벼움가상머신(Virtual machine)  하이퍼바이저를 통해 호스트 리소스에 대한 가상 액세스 권한을 가진 “게스트” 운영 체제를 실행  일반적으로 애플리케이션에서 필요한 것보다 많은 리소스 사용설치하기os 확인$ grep . /etc/*-release/etc/centos-release:CentOS Linux release 7.4.1708 (Core)CentOS 7 기준sudo yum install docker버전 확인$ docker -v # --versionDocker version 1.13.1, build 774336d/1.13.1sudo 없이 docker 명령어 실행을 위한 docker 그룹 설정$ sudo groupadd docker$ sudo gpasswd -a ${USER} docker$ sudo service docker restarthello-world이미지 리스트$ docker image lsREPOSITORY              TAG                 IMAGE ID            CREATED             SIZEhello-world 실행$ docker run hello-world  이미지기 없는 경우 자동으로 pull 된 후에 실행  이미지 리스트에 다운된 hello-world가 추가$ docker image lsREPOSITORY              TAG                 IMAGE ID            CREATED             SIZEdocker.io/hello-world   latest              e38bc07ac18e        2 weeks ago         1.85 kB컨테이너 리스트$ docker container ls # --all or -aq사용한 명령어 정리## List Docker CLI commandsdockerdocker container --help## Display Docker version and infodocker --versiondocker versiondocker info## Execute Docker imagedocker run hello-world## List Docker imagesdocker image ls## List Docker containers (running, all, all in quiet mode)docker container lsdocker container ls --alldocker container ls -aq참고 : https://docs.docker.com/get-started/",
        "url": "//docker/2018/04/27/001.html"
      }
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/0.7.1/lunr.min.js"></script>
<script src="/assets/js/search.js"></script>
</section>
</article>

    </div>
    


<footer class="site-footer">
	<p class="text">Powered by <a href="https://jekyllrb.com/">Jekyll</a> with <a href="https://github.com/rohanchandra/type-theme">Type Theme</a>
</p>
</footer>


  </body>
</html>
